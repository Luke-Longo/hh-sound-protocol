/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export type MintInfoStruct = {
  startTime: PromiseOrValue<BigNumberish>;
  endTime: PromiseOrValue<BigNumberish>;
  affiliateFeeBPS: PromiseOrValue<BigNumberish>;
  mintPaused: PromiseOrValue<boolean>;
  price: PromiseOrValue<BigNumberish>;
  maxMintable: PromiseOrValue<BigNumberish>;
  maxMintablePerAccount: PromiseOrValue<BigNumberish>;
  totalMinted: PromiseOrValue<BigNumberish>;
  merkleRootHash: PromiseOrValue<BytesLike>;
};

export type MintInfoStructOutput = [
  number,
  number,
  number,
  boolean,
  BigNumber,
  number,
  number,
  number,
  string
] & {
  startTime: number;
  endTime: number;
  affiliateFeeBPS: number;
  mintPaused: boolean;
  price: BigNumber;
  maxMintable: number;
  maxMintablePerAccount: number;
  totalMinted: number;
  merkleRootHash: string;
};

export interface MerkleDropMinterInterface extends utils.Interface {
  functions: {
    "MAX_BPS()": FunctionFragment;
    "affiliateFeesAccrued(address)": FunctionFragment;
    "createEditionMint(address,bytes32,uint96,uint32,uint32,uint16,uint32,uint32)": FunctionFragment;
    "feeRegistry()": FunctionFragment;
    "isAffiliated(address,uint128,address)": FunctionFragment;
    "mint(address,uint128,uint32,bytes32[],address)": FunctionFragment;
    "mintInfo(address,uint128)": FunctionFragment;
    "moduleInterfaceId()": FunctionFragment;
    "nextMintId()": FunctionFragment;
    "platformFeesAccrued()": FunctionFragment;
    "setAffiliateFee(address,uint128,uint16)": FunctionFragment;
    "setEditionMintPaused(address,uint128,bool)": FunctionFragment;
    "setMaxMintable(address,uint128,uint32)": FunctionFragment;
    "setMaxMintablePerAccount(address,uint128,uint32)": FunctionFragment;
    "setMerkleRootHash(address,uint128,bytes32)": FunctionFragment;
    "setPrice(address,uint128,uint96)": FunctionFragment;
    "setTimeRange(address,uint128,uint32,uint32)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "totalPrice(address,uint128,address,uint32)": FunctionFragment;
    "withdrawForAffiliate(address)": FunctionFragment;
    "withdrawForPlatform()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MAX_BPS"
      | "affiliateFeesAccrued"
      | "createEditionMint"
      | "feeRegistry"
      | "isAffiliated"
      | "mint"
      | "mintInfo"
      | "moduleInterfaceId"
      | "nextMintId"
      | "platformFeesAccrued"
      | "setAffiliateFee"
      | "setEditionMintPaused"
      | "setMaxMintable"
      | "setMaxMintablePerAccount"
      | "setMerkleRootHash"
      | "setPrice"
      | "setTimeRange"
      | "supportsInterface"
      | "totalPrice"
      | "withdrawForAffiliate"
      | "withdrawForPlatform"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "MAX_BPS", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "affiliateFeesAccrued",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createEditionMint",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "feeRegistry",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isAffiliated",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mint",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "mintInfo",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "moduleInterfaceId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nextMintId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "platformFeesAccrued",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAffiliateFee",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setEditionMintPaused",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxMintable",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setMaxMintablePerAccount",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setMerkleRootHash",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setPrice",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setTimeRange",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "totalPrice",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawForAffiliate",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawForPlatform",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "MAX_BPS", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "affiliateFeesAccrued",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createEditionMint",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "feeRegistry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isAffiliated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mint", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "mintInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "moduleInterfaceId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nextMintId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "platformFeesAccrued",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAffiliateFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setEditionMintPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxMintable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMaxMintablePerAccount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMerkleRootHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setTimeRange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "totalPrice", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawForAffiliate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawForPlatform",
    data: BytesLike
  ): Result;

  events: {
    "AffiliateFeeSet(address,uint128,uint16)": EventFragment;
    "DropClaimed(address,uint32)": EventFragment;
    "MaxMintablePerAccountSet(address,uint128,uint32)": EventFragment;
    "MaxMintableSet(address,uint128,uint32)": EventFragment;
    "MerkleDropMintCreated(address,uint128,bytes32,uint96,uint32,uint32,uint16,uint32,uint32)": EventFragment;
    "MerkleRootHashSet(address,uint128,bytes32)": EventFragment;
    "MintConfigCreated(address,address,uint128,uint32,uint32,uint16)": EventFragment;
    "MintPausedSet(address,uint128,bool)": EventFragment;
    "Minted(address,uint128,address,uint32,uint32,uint128,uint128,uint128,address,bool)": EventFragment;
    "PriceSet(address,uint128,uint96)": EventFragment;
    "TimeRangeSet(address,uint128,uint32,uint32)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AffiliateFeeSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DropClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MaxMintablePerAccountSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MaxMintableSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MerkleDropMintCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MerkleRootHashSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintConfigCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MintPausedSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Minted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PriceSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TimeRangeSet"): EventFragment;
}

export interface AffiliateFeeSetEventObject {
  edition: string;
  mintId: BigNumber;
  bps: number;
}
export type AffiliateFeeSetEvent = TypedEvent<
  [string, BigNumber, number],
  AffiliateFeeSetEventObject
>;

export type AffiliateFeeSetEventFilter = TypedEventFilter<AffiliateFeeSetEvent>;

export interface DropClaimedEventObject {
  recipient: string;
  quantity: number;
}
export type DropClaimedEvent = TypedEvent<
  [string, number],
  DropClaimedEventObject
>;

export type DropClaimedEventFilter = TypedEventFilter<DropClaimedEvent>;

export interface MaxMintablePerAccountSetEventObject {
  edition: string;
  mintId: BigNumber;
  maxMintablePerAccount: number;
}
export type MaxMintablePerAccountSetEvent = TypedEvent<
  [string, BigNumber, number],
  MaxMintablePerAccountSetEventObject
>;

export type MaxMintablePerAccountSetEventFilter =
  TypedEventFilter<MaxMintablePerAccountSetEvent>;

export interface MaxMintableSetEventObject {
  edition: string;
  mintId: BigNumber;
  maxMintable: number;
}
export type MaxMintableSetEvent = TypedEvent<
  [string, BigNumber, number],
  MaxMintableSetEventObject
>;

export type MaxMintableSetEventFilter = TypedEventFilter<MaxMintableSetEvent>;

export interface MerkleDropMintCreatedEventObject {
  edition: string;
  mintId: BigNumber;
  merkleRootHash: string;
  price: BigNumber;
  startTime: number;
  endTime: number;
  affiliateFeeBPS: number;
  maxMintable: number;
  maxMintablePerAccount: number;
}
export type MerkleDropMintCreatedEvent = TypedEvent<
  [
    string,
    BigNumber,
    string,
    BigNumber,
    number,
    number,
    number,
    number,
    number
  ],
  MerkleDropMintCreatedEventObject
>;

export type MerkleDropMintCreatedEventFilter =
  TypedEventFilter<MerkleDropMintCreatedEvent>;

export interface MerkleRootHashSetEventObject {
  edition: string;
  mintId: BigNumber;
  merkleRootHash: string;
}
export type MerkleRootHashSetEvent = TypedEvent<
  [string, BigNumber, string],
  MerkleRootHashSetEventObject
>;

export type MerkleRootHashSetEventFilter =
  TypedEventFilter<MerkleRootHashSetEvent>;

export interface MintConfigCreatedEventObject {
  edition: string;
  creator: string;
  mintId: BigNumber;
  startTime: number;
  endTime: number;
  affiliateFeeBPS: number;
}
export type MintConfigCreatedEvent = TypedEvent<
  [string, string, BigNumber, number, number, number],
  MintConfigCreatedEventObject
>;

export type MintConfigCreatedEventFilter =
  TypedEventFilter<MintConfigCreatedEvent>;

export interface MintPausedSetEventObject {
  edition: string;
  mintId: BigNumber;
  paused: boolean;
}
export type MintPausedSetEvent = TypedEvent<
  [string, BigNumber, boolean],
  MintPausedSetEventObject
>;

export type MintPausedSetEventFilter = TypedEventFilter<MintPausedSetEvent>;

export interface MintedEventObject {
  edition: string;
  mintId: BigNumber;
  buyer: string;
  fromTokenId: number;
  quantity: number;
  requiredEtherValue: BigNumber;
  platformFee: BigNumber;
  affiliateFee: BigNumber;
  affiliate: string;
  affiliated: boolean;
}
export type MintedEvent = TypedEvent<
  [
    string,
    BigNumber,
    string,
    number,
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    boolean
  ],
  MintedEventObject
>;

export type MintedEventFilter = TypedEventFilter<MintedEvent>;

export interface PriceSetEventObject {
  edition: string;
  mintId: BigNumber;
  price: BigNumber;
}
export type PriceSetEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  PriceSetEventObject
>;

export type PriceSetEventFilter = TypedEventFilter<PriceSetEvent>;

export interface TimeRangeSetEventObject {
  edition: string;
  mintId: BigNumber;
  startTime: number;
  endTime: number;
}
export type TimeRangeSetEvent = TypedEvent<
  [string, BigNumber, number, number],
  TimeRangeSetEventObject
>;

export type TimeRangeSetEventFilter = TypedEventFilter<TimeRangeSetEvent>;

export interface MerkleDropMinter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MerkleDropMinterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    MAX_BPS(overrides?: CallOverrides): Promise<[number]>;

    affiliateFeesAccrued(
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    createEditionMint(
      edition: PromiseOrValue<string>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      affiliateFeeBPS: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    feeRegistry(overrides?: CallOverrides): Promise<[string]>;

    isAffiliated(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    mint(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      requestedQuantity: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      affiliate: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    mintInfo(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MintInfoStructOutput]>;

    moduleInterfaceId(overrides?: CallOverrides): Promise<[string]>;

    nextMintId(overrides?: CallOverrides): Promise<[BigNumber]>;

    platformFeesAccrued(overrides?: CallOverrides): Promise<[BigNumber]>;

    setAffiliateFee(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      feeBPS: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setEditionMintPaused(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxMintable(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMaxMintablePerAccount(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMerkleRootHash(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTimeRange(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    totalPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<string>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    withdrawForAffiliate(
      affiliate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawForPlatform(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  MAX_BPS(overrides?: CallOverrides): Promise<number>;

  affiliateFeesAccrued(
    affiliate: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  createEditionMint(
    edition: PromiseOrValue<string>,
    merkleRootHash: PromiseOrValue<BytesLike>,
    price: PromiseOrValue<BigNumberish>,
    startTime: PromiseOrValue<BigNumberish>,
    endTime: PromiseOrValue<BigNumberish>,
    affiliateFeeBPS: PromiseOrValue<BigNumberish>,
    maxMintable: PromiseOrValue<BigNumberish>,
    maxMintablePerAccount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  feeRegistry(overrides?: CallOverrides): Promise<string>;

  isAffiliated(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<BigNumberish>,
    affiliate: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  mint(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    requestedQuantity: PromiseOrValue<BigNumberish>,
    merkleProof: PromiseOrValue<BytesLike>[],
    affiliate: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  mintInfo(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MintInfoStructOutput>;

  moduleInterfaceId(overrides?: CallOverrides): Promise<string>;

  nextMintId(overrides?: CallOverrides): Promise<BigNumber>;

  platformFeesAccrued(overrides?: CallOverrides): Promise<BigNumber>;

  setAffiliateFee(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    feeBPS: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setEditionMintPaused(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    paused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxMintable(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    maxMintable: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMaxMintablePerAccount(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    maxMintablePerAccount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMerkleRootHash(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    merkleRootHash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPrice(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    price: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTimeRange(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    startTime: PromiseOrValue<BigNumberish>,
    endTime: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  totalPrice(
    edition: PromiseOrValue<string>,
    mintId: PromiseOrValue<BigNumberish>,
    arg2: PromiseOrValue<string>,
    quantity: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  withdrawForAffiliate(
    affiliate: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawForPlatform(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    MAX_BPS(overrides?: CallOverrides): Promise<number>;

    affiliateFeesAccrued(
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createEditionMint(
      edition: PromiseOrValue<string>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      affiliateFeeBPS: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    feeRegistry(overrides?: CallOverrides): Promise<string>;

    isAffiliated(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    mint(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      requestedQuantity: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    mintInfo(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MintInfoStructOutput>;

    moduleInterfaceId(overrides?: CallOverrides): Promise<string>;

    nextMintId(overrides?: CallOverrides): Promise<BigNumber>;

    platformFeesAccrued(overrides?: CallOverrides): Promise<BigNumber>;

    setAffiliateFee(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      feeBPS: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setEditionMintPaused(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      paused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxMintable(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMaxMintablePerAccount(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setMerkleRootHash(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTimeRange(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    totalPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<string>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawForAffiliate(
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawForPlatform(overrides?: CallOverrides): Promise<void>;
  };

  filters: {
    "AffiliateFeeSet(address,uint128,uint16)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      bps?: null
    ): AffiliateFeeSetEventFilter;
    AffiliateFeeSet(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      bps?: null
    ): AffiliateFeeSetEventFilter;

    "DropClaimed(address,uint32)"(
      recipient?: null,
      quantity?: null
    ): DropClaimedEventFilter;
    DropClaimed(recipient?: null, quantity?: null): DropClaimedEventFilter;

    "MaxMintablePerAccountSet(address,uint128,uint32)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      maxMintablePerAccount?: null
    ): MaxMintablePerAccountSetEventFilter;
    MaxMintablePerAccountSet(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      maxMintablePerAccount?: null
    ): MaxMintablePerAccountSetEventFilter;

    "MaxMintableSet(address,uint128,uint32)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      maxMintable?: null
    ): MaxMintableSetEventFilter;
    MaxMintableSet(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      maxMintable?: null
    ): MaxMintableSetEventFilter;

    "MerkleDropMintCreated(address,uint128,bytes32,uint96,uint32,uint32,uint16,uint32,uint32)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      merkleRootHash?: null,
      price?: null,
      startTime?: null,
      endTime?: null,
      affiliateFeeBPS?: null,
      maxMintable?: null,
      maxMintablePerAccount?: null
    ): MerkleDropMintCreatedEventFilter;
    MerkleDropMintCreated(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      merkleRootHash?: null,
      price?: null,
      startTime?: null,
      endTime?: null,
      affiliateFeeBPS?: null,
      maxMintable?: null,
      maxMintablePerAccount?: null
    ): MerkleDropMintCreatedEventFilter;

    "MerkleRootHashSet(address,uint128,bytes32)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      merkleRootHash?: null
    ): MerkleRootHashSetEventFilter;
    MerkleRootHashSet(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      merkleRootHash?: null
    ): MerkleRootHashSetEventFilter;

    "MintConfigCreated(address,address,uint128,uint32,uint32,uint16)"(
      edition?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      mintId?: null,
      startTime?: null,
      endTime?: null,
      affiliateFeeBPS?: null
    ): MintConfigCreatedEventFilter;
    MintConfigCreated(
      edition?: PromiseOrValue<string> | null,
      creator?: PromiseOrValue<string> | null,
      mintId?: null,
      startTime?: null,
      endTime?: null,
      affiliateFeeBPS?: null
    ): MintConfigCreatedEventFilter;

    "MintPausedSet(address,uint128,bool)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: null,
      paused?: null
    ): MintPausedSetEventFilter;
    MintPausedSet(
      edition?: PromiseOrValue<string> | null,
      mintId?: null,
      paused?: null
    ): MintPausedSetEventFilter;

    "Minted(address,uint128,address,uint32,uint32,uint128,uint128,uint128,address,bool)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      buyer?: PromiseOrValue<string> | null,
      fromTokenId?: null,
      quantity?: null,
      requiredEtherValue?: null,
      platformFee?: null,
      affiliateFee?: null,
      affiliate?: null,
      affiliated?: null
    ): MintedEventFilter;
    Minted(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      buyer?: PromiseOrValue<string> | null,
      fromTokenId?: null,
      quantity?: null,
      requiredEtherValue?: null,
      platformFee?: null,
      affiliateFee?: null,
      affiliate?: null,
      affiliated?: null
    ): MintedEventFilter;

    "PriceSet(address,uint128,uint96)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      price?: null
    ): PriceSetEventFilter;
    PriceSet(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      price?: null
    ): PriceSetEventFilter;

    "TimeRangeSet(address,uint128,uint32,uint32)"(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      startTime?: null,
      endTime?: null
    ): TimeRangeSetEventFilter;
    TimeRangeSet(
      edition?: PromiseOrValue<string> | null,
      mintId?: PromiseOrValue<BigNumberish> | null,
      startTime?: null,
      endTime?: null
    ): TimeRangeSetEventFilter;
  };

  estimateGas: {
    MAX_BPS(overrides?: CallOverrides): Promise<BigNumber>;

    affiliateFeesAccrued(
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createEditionMint(
      edition: PromiseOrValue<string>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      affiliateFeeBPS: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    feeRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    isAffiliated(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    mint(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      requestedQuantity: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      affiliate: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    mintInfo(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    moduleInterfaceId(overrides?: CallOverrides): Promise<BigNumber>;

    nextMintId(overrides?: CallOverrides): Promise<BigNumber>;

    platformFeesAccrued(overrides?: CallOverrides): Promise<BigNumber>;

    setAffiliateFee(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      feeBPS: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setEditionMintPaused(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxMintable(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMaxMintablePerAccount(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMerkleRootHash(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTimeRange(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<string>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawForAffiliate(
      affiliate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawForPlatform(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    MAX_BPS(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    affiliateFeesAccrued(
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createEditionMint(
      edition: PromiseOrValue<string>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      price: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      affiliateFeeBPS: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    feeRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isAffiliated(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<BigNumberish>,
      affiliate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    mint(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      requestedQuantity: PromiseOrValue<BigNumberish>,
      merkleProof: PromiseOrValue<BytesLike>[],
      affiliate: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    mintInfo(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    moduleInterfaceId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nextMintId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    platformFeesAccrued(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setAffiliateFee(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      feeBPS: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setEditionMintPaused(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      paused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxMintable(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintable: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMaxMintablePerAccount(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      maxMintablePerAccount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMerkleRootHash(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      merkleRootHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      price: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTimeRange(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      startTime: PromiseOrValue<BigNumberish>,
      endTime: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalPrice(
      edition: PromiseOrValue<string>,
      mintId: PromiseOrValue<BigNumberish>,
      arg2: PromiseOrValue<string>,
      quantity: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdrawForAffiliate(
      affiliate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawForPlatform(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
